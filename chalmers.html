<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <title>Untitled</title>
  <style type="text/css">
    body {
  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
  color: #222;
  font-size: 100%;
}

.slide {
  position: absolute;
  top: 0; bottom: 0;
  left: 0; right: 0;
  background-color: #f7f7f7;
}

.slide-content {
  width: 800px;
  height: 600px;
  overflow: hidden;
  margin: 80px auto 0 auto;
  padding: 30px;

  font-weight: 200;
  font-size: 200%;
  line-height: 1.375;
}

.controls {
  position: absolute;
  bottom: 20px;
  left: 20px;
}

.arrow {
  width: 0; height: 0;
  border: 30px solid #333;
  float: left;
  margin-right: 30px;

  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.prev {
  border-top-color: transparent;
  border-bottom-color: transparent;
  border-left-color: transparent;

  border-left-width: 0;
  border-right-width: 50px;
}

.next {
  border-top-color: transparent;
  border-bottom-color: transparent;
  border-right-color: transparent;

  border-left-width: 50px;
  border-right-width: 0;
}

.prev:hover {
  border-right-color: #888;
  cursor: pointer;
}

.next:hover {
  border-left-color: #888;
  cursor: pointer;
}

h1 {
  font-size: 300%;
  line-height: 1.2;
  text-align: center;
  margin: 170px 0 0;
}

h2 {
  font-size: 100%;
  line-height: 1.2;
  margin: 5px 0;
  text-align: center;
  font-weight: 200;
}

h3 {
  font-size: 140%;
  line-height: 1.2;
  border-bottom: 1px solid #aaa;
  margin: 0;
  padding-bottom: 15px;
}

ul {
  padding: 20px 0 0 60px;
  font-weight: 200;
  line-height: 1.375;
}

.author h1 {
  font-size: 170%;
  font-weight: 200;
  text-align: center;
  margin-bottom: 30px;
}

.author h3 {
  font-weight: 100;
  text-align: center;
  font-size: 95%;
  border: none;
}

a {
  text-decoration: none;
  color: #44a4dd;
}

a:hover {
  color: #66b5ff;
}

pre {
  font-size: 60%;
  line-height: 1.3;
}

.progress {
  position: fixed;
  top: 0; left: 0; right: 0;
  height: 3px;
  z-index: 1;
}

.progress-bar {
  width: 0%;
  height: 3px;
  background-color: #b4b4b4;

  -webkit-transition: width 0.05s ease-out;
  -moz-transition: width 0.05s ease-out;
  -o-transition: width 0.05s ease-out;
  transition: width 0.05s ease-out;
}

.hidden {
  display: none;
}

@media (max-width: 850px) {

  body {
    font-size: 70%;
  }

  .slide-content {
    width: auto;
  }

  img {
    width: 100%;
  }

  h1 {
    margin-top: 120px;
  }

  .prev, .prev:hover {
    border-right-color: rgba(135, 135, 135, 0.5);
  }

  .next, .next:hover {
    border-left-color: rgba(135, 135, 135, 0.5);
  }
}

@media (max-width: 480px) {
  body {
    font-size: 50%;
    overflow: hidden;
  }

  .slide-content {
    padding: 10px;
    margin-top: 10px;
    height: 340px;
  }

  h1 {
    margin-top: 50px;
  }

  ul {
    padding-left: 25px;
  }
}

@media print {
  * {
    -webkit-print-color-adjust: exact;
  }

  @page {
    size: letter;
  }

  .hidden {
    display: inline;
  }

  html {
    width: 100%;
    height: 100%;
    overflow: visible;
  }

  body {
    margin: 0 auto !important;
    border: 0;
    padding: 0;
    float: none !important;
    overflow: visible;
    background: none !important;
    font-size: 52%;
  }

  .progress, .controls {
    display: none;
  }

  .slide {
    position: static;
  }

  .slide-content {
    border: 1px solid #222;
    margin-top: 0;
    margin-bottom: 40px;
    height: 3.5in;
    overflow: visible;
  }

  .slide:nth-child(even) {
    /* 2 slides per page */
    page-break-before: always;
  }
}

/*

github.com style (c) Vasily Polovnyov <vast@whiteants.net>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  background: #f8f8f8;
}

.hljs-comment,
.hljs-quote {
  color: #998;
  font-style: italic;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-subst {
  color: #333;
  font-weight: bold;
}

.hljs-number,
.hljs-literal,
.hljs-variable,
.hljs-template-variable,
.hljs-tag .hljs-attr {
  color: #008080;
}

.hljs-string,
.hljs-doctag {
  color: #d14;
}

.hljs-title,
.hljs-section,
.hljs-selector-id {
  color: #900;
  font-weight: bold;
}

.hljs-subst {
  font-weight: normal;
}

.hljs-type,
.hljs-class .hljs-title {
  color: #458;
  font-weight: bold;
}

.hljs-tag,
.hljs-name,
.hljs-attribute {
  color: #000080;
  font-weight: normal;
}

.hljs-regexp,
.hljs-link {
  color: #009926;
}

.hljs-symbol,
.hljs-bullet {
  color: #990073;
}

.hljs-built_in,
.hljs-builtin-name {
  color: #0086b3;
}

.hljs-meta {
  color: #999;
  font-weight: bold;
}

.hljs-deletion {
  background: #fdd;
}

.hljs-addition {
  background: #dfd;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}


  </style>
</head>
<body>
    <div class="progress">
    <div class="progress-bar"></div>
  </div>

  <div class="slide" id="slide-1">
    <section class="slide-content"><h2 id="declarative-vector-programming">Declarative Vector Programming</h2>
<h2 id="abhiroop-sarkar">Abhiroop Sarkar</h2>
</section>
  </div>
  <div class="slide hidden" id="slide-2">
    <section class="slide-content"><h3 id="outline">OUTLINE</h3>
<ul>
<li>Motivation</li>
<li>My Master&#39;s Thesis</li>
<li>Lift-Vector : A library for vector programming</li>
<li>An alternate programming model?</li>
<li>Automatic Vectorization (if time permits)</li>
</ul>
</section>
  </div>
  <div class="slide hidden" id="slide-3">
    <section class="slide-content"><h2 id="types-of-parallel-machines">Types of Parallel Machines</h2>
<p><img src="https://raw.githubusercontent.com/Abhiroop/Abhiroop.github.io/master/images/thesis/flynn.png" alt="Flynn"></p>
</section>
  </div>
  <div class="slide hidden" id="slide-4">
    <section class="slide-content"><h3 id="single-instruction-multiple-data">Single Instruction Multiple Data</h3>
<p> <img src="https://raw.githubusercontent.com/Abhiroop/Abhiroop.github.io/master/images/thesis/simd-example.jpg" alt="Simd"></p>
</section>
  </div>
  <div class="slide hidden" id="slide-5">
    <section class="slide-content"><h2 id="why-simd-">WHY SIMD?</h2>
</section>
  </div>
  <div class="slide hidden" id="slide-6">
    <section class="slide-content"><ul>
<li>Power efficient</li>
<li>Relative low cost in die area</li>
<li>Lesser FDE cycles for a given data size</li>
<li>ML algorithms are data parallel in nature</li>
<li>Numerical computing algorithms are data parallel</li>
</ul>
</section>
  </div>
  <div class="slide hidden" id="slide-7">
    <section class="slide-content"><p><img src="https://raw.githubusercontent.com/Abhiroop/Abhiroop.github.io/master/images/cpuvsgpu.png" alt="cvg"></p>
</section>
  </div>
  <div class="slide hidden" id="slide-8">
    <section class="slide-content"><ul>
<li>CPUs have a different memory model </li>
<li>CPUs have stricter rules for execution order of instructions</li>
<li>CPUs have stricter rules for visibility of loads and stores</li>
</ul>
</section>
  </div>
  <div class="slide hidden" id="slide-9">
    <section class="slide-content"><p>We focus on CPU vector programming.</p>
</section>
  </div>
  <div class="slide hidden" id="slide-10">
    <section class="slide-content"><h2 id="x86-instruction-set">x86 Instruction Set</h2>
<ul>
<li>Intel<ul>
<li>SSE (Intel P6, 1999)</li>
<li>SSE2 (Intel Pentium M, 2003)</li>
<li>SSE3 (NetBurst - Pentium 4, 2004)</li>
<li>SSE4.1 (Intel Core, 2006)</li>
<li>SSE4.2 (Nehalem, 2008)</li>
<li>AVX (SandyBridge, 2011)</li>
<li>AVX2 (Haswell, 2013)</li>
<li>AVX512 (Canon Lake, 2018)</li>
</ul>
</li>
<li>AMD</li>
</ul>
</section>
  </div>
  <div class="slide hidden" id="slide-11">
    <section class="slide-content"><h2 id="compiler-support">Compiler Support</h2>
<ul>
<li>GCC</li>
<li>LLVM Toolchain</li>
<li>Dyalog APL</li>
</ul>
</section>
  </div>
  <div class="slide hidden" id="slide-12">
    <section class="slide-content"><h2 id="software-support">Software Support</h2>
<ul>
<li>OpenMP</li>
<li>OpenCL</li>
</ul>
</section>
  </div>
  <div class="slide hidden" id="slide-13">
    <section class="slide-content"><p>Can a purely functional language support vectorisation?</p>
</section>
  </div>
  <div class="slide hidden" id="slide-14">
    <section class="slide-content"><p>The question is incomplete...</p>
</section>
  </div>
  <div class="slide hidden" id="slide-15">
    <section class="slide-content"><p>Can a purely functional language support vectorisation, <em>preserving its original syntax and semantics while being as efficient as low level systems programming languages</em>?</p>
</section>
  </div>
  <div class="slide hidden" id="slide-16">
    <section class="slide-content"><p>We will attempt to answer this throughout the rest of the presentation</p>
</section>
  </div>
  <div class="slide hidden" id="slide-17">
    <section class="slide-content"><h2 id="master-s-thesis">MASTER&#39;S THESIS</h2>
<h3 id="superword-level-parallelism-in-the-glasgow-haskell-compiler">Superword Level Parallelism in the Glasgow Haskell Compiler</h3>
</section>
  </div>
  <div class="slide hidden" id="slide-18">
    <section class="slide-content"><p>We will avoid talking about the engineering aspects and try to focus on the research side of the problem.</p>
</section>
  </div>
  <div class="slide hidden" id="slide-19">
    <section class="slide-content"><p><img src="https://raw.githubusercontent.com/Abhiroop/Abhiroop.github.io/master/images/thesis/pipeline.png" alt="ghcpipe"></p>
</section>
  </div>
  <div class="slide hidden" id="slide-20">
    <section class="slide-content"><p><code>Float</code> supports <code>FloatX4</code>, a vector data type</p>
<p><code>Double</code> supports <code>DoubleX2</code>, a vector data type</p>
</section>
  </div>
  <div class="slide hidden" id="slide-21">
    <section class="slide-content"><p>The user-level API</p>
<pre><code class="lang-haskell"> <span class="hljs-comment">-- constructors</span>
<span class="hljs-title">packFloatX4</span>#      :: (# <span class="hljs-type">Float</span>#, <span class="hljs-type">Float</span>#, <span class="hljs-type">Float</span>#, <span class="hljs-type">Float</span># #) -&gt; <span class="hljs-type">FloatX4</span>#
<span class="hljs-title">broadcastFloatX4</span># :: <span class="hljs-type">Float</span># -&gt; <span class="hljs-type">FloatX4</span>#
 <span class="hljs-comment">-- destructors</span>
<span class="hljs-title">unpackFloatX4</span># :: <span class="hljs-type">FloatX4</span># (# <span class="hljs-type">Float</span>#, <span class="hljs-type">Float</span>#, <span class="hljs-type">Float</span>#, <span class="hljs-type">Float</span># #)
 <span class="hljs-comment">-- operations</span>
<span class="hljs-title">plusFloatX4</span>#   :: <span class="hljs-type">FloatX4</span># -&gt; <span class="hljs-type">FloatX4</span># -&gt; <span class="hljs-type">FloatX4</span>#
<span class="hljs-title">minusFloatX4</span>#  :: <span class="hljs-type">FloatX4</span># -&gt; <span class="hljs-type">FloatX4</span># -&gt; <span class="hljs-type">FloatX4</span>#
<span class="hljs-title">timesFloatX4</span>#  :: <span class="hljs-type">FloatX4</span># -&gt; <span class="hljs-type">FloatX4</span># -&gt; <span class="hljs-type">FloatX4</span>#
<span class="hljs-title">divideFloatX4</span># :: <span class="hljs-type">FloatX4</span># -&gt; <span class="hljs-type">FloatX4</span># -&gt; <span class="hljs-type">FloatX4</span>#</code></pre>
<p>SSE as well as AVX support</p>
</section>
  </div>
  <div class="slide hidden" id="slide-22">
    <section class="slide-content"><p>Example :
Vectorizing dot product</p>
</section>
  </div>
  <div class="slide hidden" id="slide-23">
    <section class="slide-content"><p>This spoils the declarative nature of Haskell!</p>
</section>
  </div>
  <div class="slide hidden" id="slide-24">
    <section class="slide-content"><h1 id="lift-vector">Lift-Vector</h1>
<p>Polymorphic SIMD functions for vector programming</p>
</section>
  </div>
  <div class="slide hidden" id="slide-25">
    <section class="slide-content"><p>Lift-vector provides two interfaces</p>
<ul>
<li>Data.Primitive</li>
<li>Data.Operations</li>
</ul>
</section>
  </div>
  <div class="slide hidden" id="slide-26">
    <section class="slide-content"><p>Data.Primitive</p>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> (<span class="hljs-type">Num</span> <span class="hljs-title">v</span>, <span class="hljs-type">Real</span> (<span class="hljs-type">Elem</span> <span class="hljs-title">v</span>)) =&gt; <span class="hljs-type">SIMDVector</span> v <span class="hljs-keyword">where</span></span>
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Elem</span> v</span>

    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">ElemTuple</span> v</span>

    nullVector       :: v
    vectorSize       :: v -&gt; <span class="hljs-type">Int</span>
    elementSize      :: v -&gt; <span class="hljs-type">Int</span>
    broadcastVector  :: <span class="hljs-type">Elem</span> v -&gt; v
    mapVector        :: (<span class="hljs-type">Elem</span> v -&gt; <span class="hljs-type">Elem</span> v) -&gt; v -&gt; v
    zipVector        :: (<span class="hljs-type">Elem</span> v -&gt; <span class="hljs-type">Elem</span> v -&gt; <span class="hljs-type">Elem</span> v) -&gt; v -&gt; v -&gt; v
    foldVector       :: (<span class="hljs-type">Elem</span> v -&gt; <span class="hljs-type">Elem</span> v -&gt; <span class="hljs-type">Elem</span> v) -&gt; v -&gt; <span class="hljs-type">Elem</span> v
    sumVector        :: v -&gt; <span class="hljs-type">Elem</span> v
    packVector       :: <span class="hljs-type">ElemTuple</span> v -&gt; v
    unpackVector     :: v -&gt; <span class="hljs-type">ElemTuple</span> v</code></pre>
</section>
  </div>
  <div class="slide hidden" id="slide-27">
    <section class="slide-content"><p>Data.Operations</p>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> (<span class="hljs-type">Num</span> <span class="hljs-title">a</span>, <span class="hljs-type">Num</span> <span class="hljs-title">b</span>) =&gt;
      <span class="hljs-type">ArithVector</span> t a b
  <span class="hljs-keyword">where</span></span>
  <span class="hljs-comment">-- | The folding function should be commutative.</span>
  fold :: (a -&gt; a -&gt; a) -&gt; (b -&gt; b -&gt; b) -&gt; b -&gt; t b -&gt; b
  zipVec ::
       (a -&gt; a -&gt; a) -&gt; (b -&gt; b -&gt; b) -&gt; t b -&gt; t b -&gt; t b
  fmap  :: (a -&gt; a) -&gt; (b -&gt; b) -&gt; t b -&gt; t b
  <span class="hljs-comment">-- | Work efficient Blelloch Scan</span>
  scanb :: (a -&gt; a -&gt; a) -&gt; (b -&gt; b -&gt; b) -&gt; b -&gt; t b -&gt; t b</code></pre>
</section>
  </div>
  <div class="slide hidden" id="slide-28">
    <section class="slide-content"><h2 id="vectorised-containers">Vectorised Containers</h2>
<ul>
<li>Vector Lists</li>
<li>Vector Arrays (Shape polymorphic)</li>
</ul>
</section>
  </div>
  <div class="slide hidden" id="slide-29">
    <section class="slide-content"><h3 id="vector-lists">Vector Lists</h3>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">VecList</span> a = <span class="hljs-type">VecList</span> [a]</span></code></pre>
<p>A wrapper over plain lists</p>
</section>
  </div>
  <div class="slide hidden" id="slide-30">
    <section class="slide-content"><h3 id="vector-arrays">Vector Arrays</h3>
<p>Wrappers around unboxed vectors.</p>
<p><img src="https://raw.githubusercontent.com/Abhiroop/Abhiroop.github.io/master/images/thesis/repa.png" alt="unboxed"></p>
<pre><code class="lang-haskell">
<span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Data.Vector.Unboxed <span class="hljs-keyword">as</span> U

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">VecArray</span> sh a = <span class="hljs-type">VecArray</span> !sh (<span class="hljs-type">U</span>.<span class="hljs-type">Vector</span> <span class="hljs-title">a</span>)</span></code></pre>
</section>
  </div>
  <div class="slide hidden" id="slide-31">
    <section class="slide-content"><p>What does dot product look like with the parallel operators?</p>
</section>
  </div>
  <div class="slide hidden" id="slide-32">
    <section class="slide-content"><p>Vector Lists</p>
<pre><code class="lang-haskell"><span class="hljs-title">dotVec</span> :: [<span class="hljs-type">Float</span>] -&gt; [<span class="hljs-type">Float</span>] -&gt; <span class="hljs-type">Float</span>
<span class="hljs-title">dotVec</span> xs ys =
  fold (\x y -&gt; x + y :: <span class="hljs-type">FloatX4</span>) (\x y -&gt; x + y :: <span class="hljs-type">Float</span>) <span class="hljs-number">0</span> $
  zipVec
    (\x y -&gt; x * y :: <span class="hljs-type">FloatX4</span>)
    (\x y -&gt; x * y :: <span class="hljs-type">Float</span>)
    (toVecList xs)
    (toVecList ys)</code></pre>
<p>Vector Arrays </p>
<pre><code class="lang-Haskell"><span class="hljs-title">dotVec'</span> :: [<span class="hljs-type">Float</span>] -&gt; [<span class="hljs-type">Float</span>] -&gt; <span class="hljs-type">Float</span>
<span class="hljs-title">dotVec'</span> xs ys
 = <span class="hljs-keyword">let</span> l1 = length xs
       l2 = length ys
    <span class="hljs-keyword">in</span> fold (\x y -&gt; x + y :: <span class="hljs-type">FloatX4</span>) (\x y -&gt; x + y :: <span class="hljs-type">Float</span>) <span class="hljs-number">0</span> $
       zipVec
        (\x y -&gt; x * y :: <span class="hljs-type">FloatX4</span>)
        (\x y -&gt; x * y :: <span class="hljs-type">Float</span>)
        (toVecArray (<span class="hljs-type">Z</span> :. l1) xs)
        (toVecArray (<span class="hljs-type">Z</span> :. l2) ys)</code></pre>
</section>
  </div>
  <div class="slide hidden" id="slide-33">
    <section class="slide-content"><p>How are the <code>Data.Operations</code> operators implemented?</p>
</section>
  </div>
  <div class="slide hidden" id="slide-34">
    <section class="slide-content"><h3 id="zip">ZIP</h3>
<p><img src="https://raw.githubusercontent.com/Abhiroop/Abhiroop.github.io/master/images/thesis/zip.png" alt="zip"></p>
</section>
  </div>
  <div class="slide hidden" id="slide-35">
    <section class="slide-content"><h3 id="map">MAP</h3>
<p><img src="https://raw.githubusercontent.com/Abhiroop/Abhiroop.github.io/master/images/thesis/map.png" alt="map"></p>
</section>
  </div>
  <div class="slide hidden" id="slide-36">
    <section class="slide-content"><h3 id="fold">FOLD</h3>
<p><img src="https://raw.githubusercontent.com/Abhiroop/Abhiroop.github.io/master/images/thesis/fold.png" alt="fold"></p>
</section>
  </div>
  <div class="slide hidden" id="slide-37">
    <section class="slide-content"><h3 id="scan">SCAN</h3>
<p><code>scan</code> or prefix sum looks like an inherently sequential operation</p>
<pre><code class="lang-haskell">&gt; scanl (+) <span class="hljs-number">0</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]
&gt; [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">15</span>,<span class="hljs-number">21</span>,<span class="hljs-number">28</span>,<span class="hljs-number">36</span>]</code></pre>
</section>
  </div>
  <div class="slide hidden" id="slide-38">
    <section class="slide-content"><p>Lift-vector supports a work efficient parallel scan</p>
</section>
  </div>
  <div class="slide hidden" id="slide-39">
    <section class="slide-content"><h2 id="blelloch-scan">BLELLOCH SCAN</h2>
<h3 id="upsweep">UPSWEEP</h3>
<p><img src="https://raw.githubusercontent.com/Abhiroop/Abhiroop.github.io/master/images/thesis/upsweep1.png" alt="upsweep"></p>
</section>
  </div>
  <div class="slide hidden" id="slide-40">
    <section class="slide-content"><h3 id="downsweep">DOWNSWEEP</h3>
<p><img src="https://raw.githubusercontent.com/Abhiroop/Abhiroop.github.io/master/images/thesis/downsweep.png" alt="downsweep"></p>
</section>
  </div>
  <div class="slide hidden" id="slide-41">
    <section class="slide-content"><p>Benchmarks</p>
</section>
  </div>
  <div class="slide hidden" id="slide-42">
    <section class="slide-content"><p>Good benchmarks</p>
<p>Heavy reads and less write</p>
</section>
  </div>
  <div class="slide hidden" id="slide-43">
    <section class="slide-content"><p>Pearson Correlation Coefficient</p>
<p><img src="https://raw.githubusercontent.com/Abhiroop/Abhiroop.github.io/master/images/thesis/pcoeff.png" alt="coeff"></p>
</section>
  </div>
  <div class="slide hidden" id="slide-44">
    <section class="slide-content"><p><img src="https://raw.githubusercontent.com/Abhiroop/Abhiroop.github.io/master/images/thesis/pearson.png" alt="pearson"></p>
</section>
  </div>
  <div class="slide hidden" id="slide-45">
    <section class="slide-content"><p>Bad benchmarks</p>
<p>Heavy writes</p>
<p>Eg: Matrix Multiplication</p>
</section>
  </div>
  <div class="slide hidden" id="slide-46">
    <section class="slide-content"><p><img src="https://raw.githubusercontent.com/Abhiroop/Abhiroop.github.io/master/images/thesis/mmult.png" alt="mmult"></p>
</section>
  </div>
  <div class="slide hidden" id="slide-47">
    <section class="slide-content"><h2 id="lift-vector">Lift Vector</h2>
<p><a href="https://github.com/Abhiroop/lift-vector">https://github.com/Abhiroop/lift-vector</a></p>
</section>
  </div>
  <div class="slide hidden" id="slide-48">
    <section class="slide-content"><h3 id="disadvantages-of-lift-vector">DISADVANTAGES OF LIFT-VECTOR</h3>
<ul>
<li>Leaky abstraction</li>
<li>Supports just flat and regular data parallelism</li>
<li>No focus on optimizing memory layout</li>
<li>Number of rewrite opportunities missed</li>
<li>...</li>
</ul>
</section>
  </div>
  <div class="slide hidden" id="slide-49">
    <section class="slide-content"><h3 id="example">EXAMPLE</h3>
<pre><code class="lang-haskell"><span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Data.Operations <span class="hljs-keyword">as</span> Op

<span class="hljs-title">foo</span> :: <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span>
<span class="hljs-title">foo</span> x = x*x + <span class="hljs-number">1</span>

<span class="hljs-title">foo'</span> :: [<span class="hljs-type">Float</span>] -&gt; [<span class="hljs-type">Float</span>]
<span class="hljs-title">foo'</span> xs =
  <span class="hljs-type">Op</span>.fromVecList $
  <span class="hljs-type">Op</span>.fmap (\x -&gt; x + <span class="hljs-number">1</span> :: <span class="hljs-type">Float</span>) (\x -&gt; x + <span class="hljs-number">1</span> :: <span class="hljs-type">FloatX4</span>) $ 
  <span class="hljs-type">Op</span>.fmap (\x -&gt; x * x :: <span class="hljs-type">Float</span>) (\x -&gt; x * x :: <span class="hljs-type">FloatX4</span>) $
  <span class="hljs-type">Op</span>.toVecList xs</code></pre>
<p>Any calls to <code>map foo</code> should be replaced by <code>foo&#39;</code></p>
</section>
  </div>
  <div class="slide hidden" id="slide-50">
    <section class="slide-content"><p>Now,</p>
<pre><code class="lang-haskell"><span class="hljs-title">bar</span> :: [<span class="hljs-type">Float</span>] -&gt; [<span class="hljs-type">Float</span>]
<span class="hljs-title">bar</span> xs = map foo xs

<span class="hljs-title">bar</span> :: [<span class="hljs-type">Float</span>] -&gt; [<span class="hljs-type">Float</span>]
<span class="hljs-title">bar</span> = foo'

<span class="hljs-title">bar'</span> :: [[<span class="hljs-type">Float</span>]] -&gt; [[<span class="hljs-type">Float</span>]]
<span class="hljs-title">bar'</span> xss = ???</code></pre>
</section>
  </div>
  <div class="slide hidden" id="slide-51">
    <section class="slide-content"><h3 id="nested-data-parallelism">NESTED DATA PARALLELISM</h3>
</section>
  </div>
  <div class="slide hidden" id="slide-52">
    <section class="slide-content"><h3 id="blelloch-s-solution">Blelloch&#39;s solution</h3>
<p>Flatten all levels of nesting</p>
<pre><code class="lang-haskell"><span class="hljs-title">concat</span>   :: (<span class="hljs-type">ArithVector</span> t) =&gt; t (t a) -&gt; t a
<span class="hljs-title">unconcat</span> :: (<span class="hljs-type">ArithVector</span> t) =&gt; t (t a) -&gt; t b -&gt; t (t b)

<span class="hljs-title">bar'</span> :: [[<span class="hljs-type">Float</span>]] -&gt; [[<span class="hljs-type">Float</span>]]
<span class="hljs-title">bar'</span> xss = unconcat xss (bar (concat xss))</code></pre>
</section>
  </div>
  <div class="slide hidden" id="slide-53">
    <section class="slide-content"><p>This is manually impossible to define in a library</p>
<p>Need the compiler to understand nested structures</p>
</section>
  </div>
  <div class="slide hidden" id="slide-54">
    <section class="slide-content"><h3 id="memory-layout-issues">MEMORY LAYOUT ISSUES</h3>
</section>
  </div>
  <div class="slide hidden" id="slide-55">
    <section class="slide-content"><p>Records are desugared to Product Types.</p>
<p>Very common to have array of tuples.</p>
<p><code>VecArray (Float, Float, Float)</code> or <code>VecList (Float, Float, Float)</code></p>
</section>
  </div>
  <div class="slide hidden" id="slide-56">
    <section class="slide-content"><p>Current hardware supports load and store vector instructions only for <strong>contiguous</strong> data</p>
<p>*Xeon Phi instruction set supports non contiguous loads and stores</p>
</section>
  </div>
  <div class="slide hidden" id="slide-57">
    <section class="slide-content"><p>Generally structure of arrays (SOA) layout is optimal over array of structures (AOS) layout</p>
<p><img src="https://raw.githubusercontent.com/Abhiroop/Abhiroop.github.io/master/images/aosvsoa.jpg" alt="aosvsoa"></p>
</section>
  </div>
  <div class="slide hidden" id="slide-58">
    <section class="slide-content"><p>This was not explored in the existing design of <em>lift-vector</em></p>
</section>
  </div>
  <div class="slide hidden" id="slide-59">
    <section class="slide-content"><p>What are we looking for?</p>
</section>
  </div>
  <div class="slide hidden" id="slide-60">
    <section class="slide-content"><p>Tradeoff between :</p>
<ul>
<li>An alternate programming model for programming vectors</li>
<li>A smart compiler (automatic vectorization)</li>
</ul>
</section>
  </div>
  <div class="slide hidden" id="slide-61">
    <section class="slide-content"><p>Programming model</p>
<ul>
<li>Data Layout</li>
<li>Syntax</li>
<li>Semantics</li>
</ul>
</section>
  </div>
  <div class="slide hidden" id="slide-62">
    <section class="slide-content"><ul>
<li>Data layout<ul>
<li>SOA over AOS</li>
<li>Flatten nested parallelism</li>
<li>Handle nested iterators (Palmer et al. 1995)</li>
<li>... more exploration</li>
</ul>
</li>
</ul>
</section>
  </div>
  <div class="slide hidden" id="slide-63">
    <section class="slide-content"><ul>
<li>Semantics of the model<ul>
<li>Parallel by default</li>
<li>Express divergent control flow (Karrenberg et al. 2017)</li>
<li>Differentiate between convergent and divergent control flow</li>
<li>Eagerly evaluated</li>
<li>Leverage fusion wherever possible</li>
</ul>
</li>
</ul>
</section>
  </div>
  <div class="slide hidden" id="slide-64">
    <section class="slide-content"><ul>
<li>Syntax<ul>
<li>Declarative</li>
</ul>
</li>
</ul>
</section>
  </div>
  <div class="slide hidden" id="slide-65">
    <section class="slide-content"><h3 id="example">Example</h3>
<pre><code class="lang-haskell"> <span class="hljs-comment">-- all functions have parallel semantics unless specified otherwise</span>
<span class="hljs-title">quicksort</span> :: [<span class="hljs-type">Float</span>] -&gt; [<span class="hljs-type">Float</span>]
<span class="hljs-title">quicksort</span> [] = []
<span class="hljs-title">quicksort</span> xs = 
  <span class="hljs-keyword">let</span> pivot = srandom xs <span class="hljs-comment">-- assume srandom pure &amp; sequential</span>
      small = select (p &lt;= pivot) xs 
      large = select (p &gt;  pivot) xs
   <span class="hljs-keyword">in</span> (quicksort small) ++ [x] ++ (quicksort large)
         gang1                         gang2
 <span class="hljs-comment">-- irregular data size but NDP can be made work efficient</span></code></pre>
<p>Simply uses relational operators </p>
<p>Vector instruction <code>CMPPS</code>in SSE or <code>VCMPPS</code> in AVX</p>
</section>
  </div>
  <div class="slide hidden" id="slide-66">
    <section class="slide-content"><p>Merge sort is easier to parallelize</p>
<pre><code> [16 elems]    [16elems]
  8      8      8     8
 4 4    4 4    4 4   4 4 
mergesort_spmd xs
  let pivot    = smiddle xs 
      (x1, x2) = split xs
   in merge (mergesort_spmd x1) (mergesort_spmd x2)

merge :: [a] -&gt; [a] -&gt; [a] - Vectorized SIMD union</code></pre>
<pre><code>            xs = [9,7,8,1]
           /    |     \    \
          /     |      \    \
         /      |       \    \
        /       |        \    \
 (fork xs) (fork xs) (fork xs) (fork xs)

              foo = pack (9,7,8,1)
              bar = broadcast pivot
              (a,b)    foo &lt; bar</code></pre>
</section>
  </div>
  <div class="slide hidden" id="slide-67">
    <section class="slide-content"><p>An existing model on GPUs - SPMD (OpenCL)!</p>
</section>
  </div>
  <div class="slide hidden" id="slide-68">
    <section class="slide-content"><p>Intel ispc compiler - SPMD on SIMD</p>
</section>
  </div>
  <div class="slide hidden" id="slide-69">
    <section class="slide-content"><h2 id="why-not-just-use-ispc-">Why not just use ISPC?</h2>
</section>
  </div>
  <div class="slide hidden" id="slide-70">
    <section class="slide-content"><ul>
<li>No nested data parallelism</li>
<li>Impure, doesn&#39;t provide &quot;safe&quot; parallelism</li>
<li>A systems language replicating the entire C pointer model</li>
<li>Explicit <em>uniform</em> and <em>varying</em> memory annotations</li>
</ul>
</section>
  </div>
  <div class="slide hidden" id="slide-71">
    <section class="slide-content"><h3 id="a-non-goal">A non-goal</h3>
<p>&quot;The target users for ispc are performance-focused programmers. Therefore, a key design goal is that the system should provide performance transparency: just as with C, it should be straightforward for the user to understand how code written in the language will be compiled to the hardware and roughly how the code will perform.&quot;</p>
</section>
  </div>
  <div class="slide hidden" id="slide-72">
    <section class="slide-content"><p>So how do we implement our language?</p>
</section>
  </div>
  <div class="slide hidden" id="slide-73">
    <section class="slide-content"><h3 id="engineering-decision">Engineering decision</h3>
<ul>
<li>GHC might be coaxed to admit nested data parallelism (using source plugins) but SPMD requires major changes in the runtime.</li>
<li>Write a small functional frontend to LLVM which flattens the data as an optimizer pass.</li>
<li>Cajole the NESL runtime to an SPMD form and connect it to LLVM.</li>
</ul>
</section>
  </div>
  <div class="slide hidden" id="slide-74">
    <section class="slide-content"><h2 id="conclusion">Conclusion</h2>
<p>Haskell has shown[1] that performance at the cost of expressivity is not necessary</p>
<p>There is a always a sweet spot!</p>
</section>
  </div>
  <div class="slide hidden" id="slide-75">
    <section class="slide-content"><h2 id="reference">Reference</h2>
<p>[1] Exploiting Vector Instructions with Generalized Stream Fusion. Mainland et al</p>
</section>
  </div>
  <div class="slide hidden" id="slide-76">
    <section class="slide-content"><p>THANK YOU FOR LISTENING</p>
</section>
  </div>
  <div class="slide hidden" id="slide-77">
    <section class="slide-content"><p>EXTRA SLIDES</p>
</section>
  </div>
  <div class="slide hidden" id="slide-78">
    <section class="slide-content"><h3 id="disadvantages-of-the-spmd-ndp-model">DISADVANTAGES OF THE SPMD-NDP MODEL</h3>
<ul>
<li>complex control flow</li>
<li>V.IMP: Full vectorization can be disastrous</li>
<li>Flattening destroys the original loops and spoils a number of optimization opportunities</li>
</ul>
</section>
  </div>
  <div class="slide hidden" id="slide-79">
    <section class="slide-content"><h3 id="cost-of-vectorization">COST OF VECTORIZATION</h3>
<ul>
<li>Cost model<ul>
<li>Work and Depth (Blelloch, 1996)</li>
<li>Compiler cost model (reducing pack, unpacks, scatters, gathers)</li>
</ul>
</li>
</ul>
</section>
  </div>
  <div class="slide hidden" id="slide-80">
    <section class="slide-content"><h3 id="throttled-superword-level-parallelism">Throttled Superword Level Parallelism</h3>
</section>
  </div>
  <div class="slide hidden" id="slide-81">
    <section class="slide-content"><p>Convert IR to SSA form</p>
<p> Cytron&#39;s algorithm</p>
</section>
  </div>
  <div class="slide hidden" id="slide-82">
    <section class="slide-content"><p>Hand made graph still SLP vectorized version slower than sequential version of the program</p>
</section>
  </div>
  <div class="slide hidden" id="slide-83">
    <section class="slide-content"><p>Throttle the vectorization by cutting the graph</p>
</section>
  </div>
  <div class="slide hidden" id="slide-84">
    <section class="slide-content"><p>Throttling is NP Hard</p>
</section>
  </div>
  <div class="slide hidden" id="slide-85">
    <section class="slide-content"><p>Can we auto vectorise faster?</p>
</section>
  </div>
  <div class="slide hidden author-slide" id="slide-86">
    <section class="slide-content"><div class="author">
  <h1 class="name">Abhiroop Sarkar</h1>
    <h3 class="twitter">
      <a href="http://twitter.com/@catamorphic">@catamorphic</a>
    </h3>
    <h3 class="url">
      <a href="https://github.com/Abhiroop/lift-vector">https://github.com/Abhiroop/lift-vector</a>
    </h3>
</div>
</section>
  </div>

  <div class="controls">
    <div class="arrow prev"></div>
    <div class="arrow next"></div>
  </div>


  <script type="text/javascript">
    /**
 * Returns the current page number of the presentation.
 */
function currentPosition() {
  return parseInt(document.querySelector('.slide:not(.hidden)').id.slice(6));
}


/**
 * Navigates forward n pages
 * If n is negative, we will navigate in reverse
 */
function navigate(n) {
  var position = currentPosition();
  var numSlides = document.getElementsByClassName('slide').length;

  /* Positions are 1-indexed, so we need to add and subtract 1 */
  var nextPosition = (position - 1 + n) % numSlides + 1;

  /* Normalize nextPosition in-case of a negative modulo result */
  nextPosition = (nextPosition - 1 + numSlides) % numSlides + 1;

  document.getElementById('slide-' + position).classList.add('hidden');
  document.getElementById('slide-' + nextPosition).classList.remove('hidden');

  updateProgress();
  updateURL();
  updateTabIndex();
}


/**
 * Updates the current URL to include a hashtag of the current page number.
 */
function updateURL() {
  try {
    window.history.replaceState({} , null, '#' + currentPosition());
  } catch (e) {
    window.location.hash = currentPosition();
  }
}


/**
 * Sets the progress indicator.
 */
function updateProgress() {
  var progressBar = document.querySelector('.progress-bar');

  if (progressBar !== null) {
    var numSlides = document.getElementsByClassName('slide').length;
    var position = currentPosition() - 1;
    var percent = (numSlides === 1) ? 100 : 100 * position / (numSlides - 1);
    progressBar.style.width = percent.toString() + '%';
  }
}


/**
 * Removes tabindex property from all links on the current slide, sets
 * tabindex = -1 for all links on other slides. Prevents slides from appearing
 * out of control.
 */
function updateTabIndex() {
  var allLinks = document.querySelectorAll('.slide a');
  var position = currentPosition();
  var currentPageLinks = document.getElementById('slide-' + position).querySelectorAll('a');
  var i;

  for (i = 0; i < allLinks.length; i++) {
    allLinks[i].setAttribute('tabindex', -1);
  }

  for (i = 0; i < currentPageLinks.length; i++) {
    currentPageLinks[i].removeAttribute('tabindex');
  }
}

/**
 * Determines whether or not we are currently in full screen mode
 */
function isFullScreen() {
  return document.fullscreenElement ||
         document.mozFullScreenElement ||
         document.webkitFullscreenElement ||
         document.msFullscreenElement;
}

/**
 * Toggle fullScreen mode on document element.
 * Works on chrome (>= 15), firefox (>= 9), ie (>= 11), opera(>= 12.1), safari (>= 5).
 */
function toggleFullScreen() {
  /* Convenient renames */
  var docElem = document.documentElement;
  var doc = document;

  docElem.requestFullscreen =
      docElem.requestFullscreen ||
      docElem.msRequestFullscreen ||
      docElem.mozRequestFullScreen ||
      docElem.webkitRequestFullscreen.bind(docElem, Element.ALLOW_KEYBOARD_INPUT);

  doc.exitFullscreen =
      doc.exitFullscreen ||
      doc.msExitFullscreen ||
      doc.mozCancelFullScreen ||
      doc.webkitExitFullscreen;

  isFullScreen() ? doc.exitFullscreen() : docElem.requestFullscreen();
}

document.addEventListener('DOMContentLoaded', function () {
  // Update the tabindex to prevent weird slide transitioning
  updateTabIndex();

  // If the location hash specifies a page number, go to it.
  var page = window.location.hash.slice(1);
  if (page) {
    navigate(parseInt(page) - 1);
  }

  document.onkeydown = function (e) {
    var kc = e.keyCode;

    // left, down, H, J, backspace, PgUp - BACK
    // up, right, K, L, space, PgDn - FORWARD
    // enter - FULLSCREEN
    if (kc === 37 || kc === 40 || kc === 8 || kc === 72 || kc === 74 || kc === 33) {
      navigate(-1);
    } else if (kc === 38 || kc === 39 || kc === 32 || kc === 75 || kc === 76 || kc === 34) {
      navigate(1);
    } else if (kc === 13) {
      toggleFullScreen();
    }
  };

  if (document.querySelector('.next') && document.querySelector('.prev')) {
    document.querySelector('.next').onclick = function (e) {
      e.preventDefault();
      navigate(1);
    };

    document.querySelector('.prev').onclick = function (e) {
      e.preventDefault();
      navigate(-1);
    };
  }
});


  </script>
</body>
</html>
